diff --git a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/EventProcessor.java b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/EventProcessor.java
index 276983a..055efe2 100644
--- a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/EventProcessor.java
+++ b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/EventProcessor.java
@@ -44,8 +44,11 @@ import de.fhhannover.inform.iron.mapserver.communication.bus.messages.SendRespon
 import de.fhhannover.inform.iron.mapserver.communication.bus.messages.TimerExpiredEvent;
 import de.fhhannover.inform.iron.mapserver.communication.http.ActionProcessor;
 import de.fhhannover.inform.iron.mapserver.datamodel.DataModelService;
+import de.fhhannover.inform.iron.mapserver.datamodel.search.ResultItem;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.PollResult;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.SearchResult;
+import de.fhhannover.inform.iron.mapserver.datamodel.graph.GraphElement;
+import de.fhhannover.inform.iron.mapserver.exceptions.SessionNotFoundException;
 import de.fhhannover.inform.iron.mapserver.exceptions.AbortRequestException;
 import de.fhhannover.inform.iron.mapserver.exceptions.AccessDeniedException;
 import de.fhhannover.inform.iron.mapserver.exceptions.InvalidFilterException;
@@ -1453,6 +1456,21 @@ public class EventProcessor extends Processor<Event> {
 				logRawResponse(sra);
 			
 			as.add(sra);
+                        try {
+                             Session ses = mSessionRep.getBy(chId);
+                             if (ses.getArc() != chId) {
+                                  //don't care about ssrc channel events
+                                  continue;
+                             }
+                             Long time = findOldestVisitedElementTimeStamp(r);
+                             if (time == -1) {
+                                   continue;
+                             }
+                             mSessionRep.setMostRecentlyVisitedGraphElementTime(chId, time);
+                        } catch (SessionNotFoundException e) {
+                             sLogger.warn(sName + "Session not found channel : " + chId + " :" + e.getMessage());
+                             continue;
+                        }
 		}
 
 		if (as.getActions().size() > 0)
@@ -1461,6 +1479,43 @@ public class EventProcessor extends Processor<Event> {
 		list.clear();
 	}
 
+/*
+        private Long sentElementTimeStamp(PollResult pr) {
+                Long most_recent_visited_element_time_stamp = new Long(0);
+                for (SearchResult sr : pr.getResults()) {
+                        Long t = sentElementTimeStamp(sr);
+                        if (t > most_recent_visited_element_time_stamp) {
+                             most_recent_visited_element_time_stamp = t;
+                        }
+                }
+                return most_recent_visited_element_time_stamp;
+        }
+
+        private Long sentElementTimeStamp(SearchResult result) {
+                Long most_recent_visited_element_time_stamp = new Long(0);
+                for (ResultItem ri : result.getResultItems()) {
+                        GraphElement ge = ri.getGraphElement();
+                        sLogger.debug("sentElementTimeStamp: ge: " + ge + ", lastModifiedTime: " + ge.getLastModifiedTime() + ";  GE: " + ge);
+                        if (ge.getLastModifiedTime() > most_recent_visited_element_time_stamp) {
+                             most_recent_visited_element_time_stamp = ge.getLastModifiedTime();
+                        }
+                }
+                return most_recent_visited_element_time_stamp;
+        }
+*/
+
+        public long findOldestVisitedElementTimeStamp(Result result) {
+                if (result == null) {
+                     return 0;
+                }
+                long most_oldest_visited_element_time_stamp  = new Long(System.currentTimeMillis());
+                if (result instanceof AddressedPollResult) {
+                        AddressedPollResult pr = (AddressedPollResult)result;
+                        most_oldest_visited_element_time_stamp = pr.getPollResult().getOldtestItemTimeStamp();
+                }
+                return most_oldest_visited_element_time_stamp;
+        }
+
 	/**
 	 * Helper to put a {@link ActionSeries} into the action queue.
 	 * 
@@ -1521,6 +1576,7 @@ public class EventProcessor extends Processor<Event> {
 	public void setDataModel(DataModelService dataModel) {
 		NullCheck.check(dataModel, "param dataModel null");
 		mDataModel = dataModel;
+                mDataModel.setSessionRepo(mSessionRep);
 	}
 
 	public void setSessionTimerFactory(SessionTimerFactory timerfactory) {
diff --git a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/PollResultsPending.java b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/PollResultsPending.java
index 43e638d..75122cd 100644
--- a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/PollResultsPending.java
+++ b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/PollResultsPending.java
@@ -12,12 +12,19 @@ package de.fhhannover.inform.iron.mapserver.communication.ifmap;
 
 import java.util.List;
 import java.util.ArrayList;
+import java.util.TreeSet;
+import java.util.Comparator;
 import java.util.Map;
 import java.util.HashMap;
 
 import org.apache.log4j.Logger;
 
 import de.fhhannover.inform.iron.mapserver.datamodel.search.PollResult;
+import de.fhhannover.inform.iron.mapserver.datamodel.search.ResultItem;
+import de.fhhannover.inform.iron.mapserver.messages.Result;
+import de.fhhannover.inform.iron.mapserver.datamodel.graph.GraphElement;
+import de.fhhannover.inform.iron.mapserver.messages.AddressedPollResult;
+import de.fhhannover.inform.iron.mapserver.messages.AddressedSearchResult;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.PollResultImpl;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.SearchResult;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.ModifiableSearchResult;
@@ -33,9 +40,19 @@ public class PollResultsPending {
 		sLogger = LoggingProvider.getTheLogger();
 	}
 	
-        private HashMap<String , List<PollResult>> mPollResults = new HashMap<String, List<PollResult>>();
+        private HashMap<String , TreeSet<PollResult>> mPollResults = new HashMap<String, TreeSet<PollResult>>();
         private HashMap<String, Integer> mPerClientMpprs = new HashMap<String, Integer>();
 
+        class PollResultsComp implements Comparator<PollResult>{
+             @Override
+             public int compare(PollResult pr1, PollResult pr2) {
+                  if(pr1.getOldtestItemTimeStamp() < pr2.getOldtestItemTimeStamp()){
+                        return -1;
+                  } 
+                  return 1;
+             }
+         }
+
 	/**
 	 * Constructor
 	 * 
@@ -44,8 +61,8 @@ public class PollResultsPending {
 	public PollResultsPending() {
 	}
 
-        private List<PollResult> getSessionResults(String sessionId) {
-                List<PollResult> sessionResults = null;
+        private TreeSet<PollResult> getSessionResults(String sessionId) {
+                TreeSet<PollResult> sessionResults = null;
                 if ((sessionResults = mPollResults.get(sessionId)) == null) {
                      sLogger.error("Session: " + sessionId + " is not initialzed with PollPendingResult when session is created");
                 }
@@ -55,9 +72,9 @@ public class PollResultsPending {
         public void handleNewSession(Session session, Integer mpprs) {
                 String sessionId = session.getSessionId();
                 sLogger.trace(sName +  ": " + sessionId + " handling new session, mpprs: " + mpprs);
-                List<PollResult> sessionResults = null;
+                TreeSet<PollResult> sessionResults = null;
                 if ((sessionResults = mPollResults.get(sessionId)) == null) {
-                     sessionResults = new ArrayList<PollResult>();
+                     sessionResults = new TreeSet<PollResult>(new PollResultsComp());
                      mPollResults.put(sessionId, sessionResults);
                      session.unsetPollPendingResultsAvailable();
                      mPerClientMpprs.put(sessionId, mpprs);
@@ -69,7 +86,7 @@ public class PollResultsPending {
         public void handleEndSession(Session session) {
                 String sessionId = session.getSessionId();
                 sLogger.trace(sName +  ": " + sessionId + " handing end session");
-                List<PollResult> sessionResults = null;
+                TreeSet<PollResult> sessionResults = null;
                 if ((sessionResults = mPollResults.get(sessionId)) == null) {
                      sLogger.error("Session : " + sessionId + " is not initialzed with PollPendingResult, but received a end session request");
                 } else {
@@ -84,8 +101,12 @@ public class PollResultsPending {
                 sLogger.trace(sName +  ": " + sessionId + " addPollResult");
                 if (canSplit(res, mpprs)) {
                        List<PollResult> newResults = split(res, mpprs);
-                       getSessionResults(sessionId).addAll(newResults);
+                       for (PollResult pr:newResults)   {
+                            pr.setOldtestItemTimeStamp(findOldestVisitedElementTimeStamp((Result)pr)); 
+                            getSessionResults(sessionId).add(pr);
+                       }
                 } else {
+                       res.setOldtestItemTimeStamp(findOldestVisitedElementTimeStamp((Result)res));
                        getSessionResults(sessionId).add(res);
                 }
                 session.setPollPendingResultsAvailable();
@@ -124,14 +145,13 @@ public class PollResultsPending {
 
         public PollResult getNext(Session session) {
                 String sessionId = session.getSessionId();
-                List<PollResult> sessionResults = mPollResults.get(sessionId);
+                TreeSet<PollResult> sessionResults = mPollResults.get(sessionId);
                 NullCheck.check(sessionResults, "Session Poll Results is null");
                 if (sessionResults.size() == 0) {
                         sLogger.warn(sName +  ": " + sessionId + " getNext must not be called because state must have been set to PollPendingResultsNone");
                         return null;
                 }
-                PollResult nextResult  = sessionResults.get(0);
-                sessionResults.remove(0);
+                PollResult nextResult  = sessionResults.pollFirst();
                 if (sessionResults.size() > 0) {
                        sLogger.trace(sName +  ": Session - " + sessionId + " has more pending results, remaining count: " + sessionResults.size());
                        session.setPollPendingResultsAvailable();
@@ -142,6 +162,46 @@ public class PollResultsPending {
                 return nextResult;
         }
 
+        private Long sentElementTimeStamp(PollResult pr) {
+                Long most_oldest_visited_element_time_stamp = new Long(System.currentTimeMillis());
+                for (SearchResult sr : pr.getResults()) {
+                        Long t = sentElementTimeStamp(sr);
+                        if (t < most_oldest_visited_element_time_stamp) {
+                             most_oldest_visited_element_time_stamp = t;
+                        }
+                }
+                return most_oldest_visited_element_time_stamp;
+        }
+
+        private Long sentElementTimeStamp(SearchResult result) {
+                Long most_oldest_visited_element_time_stamp = new Long(System.currentTimeMillis());
+                for (ResultItem ri : result.getResultItems()) {
+                        GraphElement ge = ri.getGraphElement();
+                        if (ge.getLastModifiedTime() < most_oldest_visited_element_time_stamp) {
+                             sLogger.debug("most oldest item visited: ge: " + ge + ", lastModifiedTime: " + ge.getLastModifiedTime() + ";  GE: " + ge);
+                             most_oldest_visited_element_time_stamp = ge.getLastModifiedTime();
+                        }
+                }
+                return most_oldest_visited_element_time_stamp;
+        }
+
+        public long findOldestVisitedElementTimeStamp(Result result) {
+                if (result == null) {
+                     return 0;
+                }
+                long most_oldest_visited_element_time_stamp  = 0;
+                if (result instanceof AddressedPollResult) {
+                        AddressedPollResult pr = (AddressedPollResult)result;
+                        most_oldest_visited_element_time_stamp = sentElementTimeStamp(pr.getPollResult());
+                } else if (result instanceof AddressedSearchResult) {
+                        AddressedSearchResult sr = (AddressedSearchResult)result;
+                        most_oldest_visited_element_time_stamp  = sentElementTimeStamp(sr.getSearchResult());
+                } else {
+                        return -1;
+                }
+                return most_oldest_visited_element_time_stamp;
+        }
+
         private void remove(String sessionId) {
                 sLogger.trace(sName +  ": Session - " + sessionId + " removed from pending results list");
                 mPollResults.remove(sessionId);
diff --git a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepository.java b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepository.java
index fd8b39d..4446dfa 100644
--- a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepository.java
+++ b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepository.java
@@ -21,6 +21,8 @@
 
 package de.fhhannover.inform.iron.mapserver.communication.ifmap;
 
+import java.util.Map;
+
 import de.fhhannover.inform.iron.mapserver.communication.ChannelIdentifier;
 import de.fhhannover.inform.iron.mapserver.communication.ClientIdentifier;
 import de.fhhannover.inform.iron.mapserver.exceptions.AlreadyMappedException;
@@ -90,6 +92,10 @@ public interface SessionRepository {
 	 * @throws StillMappedException if mappings have not been removed
 	 */
 	public void drop(Session session) throws SessionNotFoundException, StillMappedException;
+
+        public void setMostRecentlyVisitedGraphElementTime(ChannelIdentifier channelId, Long time) throws SessionNotFoundException;
+        public Long oldestGraphElementVisitedTime();
+        public Map<String, Long> getSessionElementVisitTimeMap();
 	
 	/**
 	 * Maps a Session to a sessionId.
diff --git a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepositoryImpl.java b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepositoryImpl.java
index c6cb1f7..e0057a9 100644
--- a/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepositoryImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/communication/ifmap/SessionRepositoryImpl.java
@@ -23,6 +23,7 @@ package de.fhhannover.inform.iron.mapserver.communication.ifmap;
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Iterator;
 
 import de.fhhannover.inform.iron.mapserver.communication.ChannelIdentifier;
 import de.fhhannover.inform.iron.mapserver.communication.ClientIdentifier;
@@ -56,6 +57,10 @@ public class SessionRepositoryImpl implements SessionRepository {
 	 * Holds mappings from session-id to {@link Session}
 	 */
 	private Map<String, Session> mSessionIdSessionMap;
+	/**
+	 * Holds mappings from arc channels to most recently sent graph element timestamp
+	 */
+	private Map<String, Long> mSessionElementVisitTime;
 	
 	/**
 	 * Construct a {@link SessionRepository}
@@ -64,6 +69,7 @@ public class SessionRepositoryImpl implements SessionRepository {
 		mClientIdSessionMap = new HashMap<ClientIdentifier, Session>();
 		mChannelIdSessionMap = new HashMap<ChannelIdentifier, Session>();
 		mSessionIdSessionMap = new HashMap<String, Session>();
+		mSessionElementVisitTime = new HashMap<String, Long>();
 	}
 	
 
@@ -86,25 +92,66 @@ public class SessionRepositoryImpl implements SessionRepository {
 	}
 
 	@Override
-	public void store(Session session) throws AlreadyStoredException {
+	public synchronized void store(Session session) throws AlreadyStoredException {
 		Session stored = getSessionWithChecks(session);
 		if (stored != null) {
 			throw new AlreadyStoredException(session.toString() + " already stored");
 		}
 		
 		mClientIdSessionMap.put(session.getClientIdentifier(), session);
+		mSessionElementVisitTime.put(session.getSessionId(), new Long(-1));
 	}
 
 	@Override
-	public void drop(Session session) throws SessionNotFoundException, StillMappedException {
+	public synchronized void drop(Session session) throws SessionNotFoundException, StillMappedException {
 		sanityCheckBeforeDropOf(session);
 		Session stored = getSessionWithChecksExpectExists(session);
 		mClientIdSessionMap.remove(stored.getClientIdentifier());
+		mSessionElementVisitTime.remove(session.getSessionId());
 	}
 
+        @Override
+        public synchronized void setMostRecentlyVisitedGraphElementTime(ChannelIdentifier channelId, Long time) throws SessionNotFoundException {
+               Session session = mChannelIdSessionMap.get(channelId);
+               if (session.getArc() != channelId) {
+                     return;
+               }
+               mSessionElementVisitTime.put(session.getSessionId(), time);
+        }
+
+        @Override
+        public synchronized Long oldestGraphElementVisitedTime() {
+               Long time = new Long(-1);
+               Iterator it = mSessionElementVisitTime.entrySet().iterator();
+               while (it.hasNext()) {
+                     Map.Entry pair = (Map.Entry)it.next();
+                     String sesId = (String)pair.getKey();
+                     Session ses = mSessionIdSessionMap.get(sesId);
+                     if (ses.getArc() == null) {
+                          //don't care ssrc channels
+                          continue;
+                     }
+                     Long t = (Long)pair.getValue();
+                     if (t == -1) {
+                          continue;
+                     }
+                     if (time == -1) {
+                           time = t;
+                     } else if (t < time) {
+                           time = t;
+                     }
+               }
+               return time;
+        }
+
+        @Override
+        public synchronized Map<String, Long> getSessionElementVisitTimeMap() {
+               return mSessionElementVisitTime;
+        }
+
 
 	@Override
-	public void map(Session session, String sessionId)
+	public synchronized void map(Session session, String sessionId)
 			throws SessionNotFoundException, AlreadyMappedException {
 		Session stored = getSessionWithChecksExpectExists(session);
 		Session mapped = getBy(sessionId);
@@ -113,10 +160,11 @@ public class SessionRepositoryImpl implements SessionRepository {
 		}
 		
 		mSessionIdSessionMap.put(sessionId, session);
+		mSessionElementVisitTime.put(session.getSessionId(), new Long(-1));
 	}
 
 	@Override
-	public void unmap(Session session, String sessionId)
+	public synchronized void unmap(Session session, String sessionId)
 			throws SessionNotFoundException, NoMappingException {
 		
 		Session stored = getSessionWithChecksExpectExists(session);
@@ -126,10 +174,11 @@ public class SessionRepositoryImpl implements SessionRepository {
 		}
 		
 		mSessionIdSessionMap.remove(sessionId);
+		mSessionElementVisitTime.remove(sessionId);
 	}
 
 	@Override
-	public void map(Session session, ChannelIdentifier channelId)
+	public synchronized void map(Session session, ChannelIdentifier channelId)
 			throws SessionNotFoundException, AlreadyMappedException {
 		Session stored = getSessionWithChecksExpectExists(session);
 		Session mapped = getBy(channelId);
@@ -138,10 +187,11 @@ public class SessionRepositoryImpl implements SessionRepository {
 		}
 		
 		mChannelIdSessionMap.put(channelId, session);
+		mSessionElementVisitTime.put(session.getSessionId(), new Long(-1));
 	}
 
 	@Override
-	public void unmap(Session session, ChannelIdentifier channelId)
+	public synchronized void unmap(Session session, ChannelIdentifier channelId)
 			throws SessionNotFoundException, NoMappingException {
 		
 		Session stored = getSessionWithChecksExpectExists(session);
@@ -151,6 +201,7 @@ public class SessionRepositoryImpl implements SessionRepository {
 		}
 		
 		mChannelIdSessionMap.remove(channelId);
+		mSessionElementVisitTime.remove(session.getSessionId());
 	}
 	
 	private Session getSessionWithChecks(Session session) {
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/DataModelService.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/DataModelService.java
index b7a1a6e..81ad4bb 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/DataModelService.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/DataModelService.java
@@ -33,6 +33,7 @@ import de.fhhannover.inform.iron.mapserver.datamodel.search.PollResult;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.SearchResult;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.SearchingFactory;
 import de.fhhannover.inform.iron.mapserver.datamodel.search.SearchingFactoryImpl;
+import de.fhhannover.inform.iron.mapserver.communication.ifmap.SessionRepository;
 import de.fhhannover.inform.iron.mapserver.exceptions.AlreadyObservedException;
 import de.fhhannover.inform.iron.mapserver.exceptions.InvalidMetadataException;
 import de.fhhannover.inform.iron.mapserver.exceptions.NoPollResultAvailableException;
@@ -86,7 +87,7 @@ public class DataModelService implements SubscriptionNotifier {
 	
 		publisherRep = new PublisherRep();
 		
-		mGraph = GraphElementRepositoryImpl.newInstance();
+		mGraph = GraphElementRepositoryImpl.newInstance(publisherRep);
 		mMetaHolderFac = MetadataHolderFactoryImpl.newInstance();
 		mSearchingFac = SearchingFactoryImpl.newInstance();
 
@@ -101,7 +102,10 @@ public class DataModelService implements SubscriptionNotifier {
 		
 		clientService = new ClientService(publisherRep, subscriptionService);
 	}
- 
+
+        public void setSessionRepo(SessionRepository sessionRep) {
+                mGraph.setSessionRepo(sessionRep);
+        }
 	
 	/**
 	 * Returns a <b>new </b> {@link DataModelService} instance.
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/PublisherRep.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/PublisherRep.java
index d181650..ba9fd65 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/PublisherRep.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/PublisherRep.java
@@ -21,6 +21,7 @@
 
 package de.fhhannover.inform.iron.mapserver.datamodel;
 
+import java.util.Collection;
 import java.util.HashMap;
 
 import org.apache.log4j.Logger;
@@ -35,7 +36,7 @@ import de.fhhannover.inform.iron.mapserver.provider.LoggingProvider;
  * @since 0.1.0
  * @author aw, vp
  */
-class PublisherRep {
+public class PublisherRep {
 	
 	private static Logger logger;
 	
@@ -159,5 +160,9 @@ class PublisherRep {
 	void removePublisherSession(String sessionId) {
 		sessions.remove(sessionId);
 	}
+
+	public Collection<Publisher> getPublishers() {
+		return publishers.values();
+	}
 }
  
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/SubscriptionService.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/SubscriptionService.java
index 1ad0449..a5d890c 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/SubscriptionService.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/SubscriptionService.java
@@ -561,6 +561,8 @@ public class SubscriptionService {
 		
 		// remove reference from publisher
 		mh.getPublisher().removeMetadataHolder(mh);
+
+		mGraph.metadataHoldeRemoved(ge);
 	}
 	
 	private void checkForAddedSubGraph(GraphElement ge, MetadataHolder mh) {
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyLinkImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyLinkImpl.java
index fa48aa1..7d7251f 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyLinkImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyLinkImpl.java
@@ -28,6 +28,7 @@ class DummyLinkImpl extends DummyGraphElement implements Link {
 	
 	private final Node mNode1;
 	private final Node mNode2;
+        private Long mLastModifiedTime;
 	
 	DummyLinkImpl(Node n1, Node n2) {
 		NullCheck.check(n1, "node1 is null");
@@ -37,6 +38,7 @@ class DummyLinkImpl extends DummyGraphElement implements Link {
 		
 		mNode1 = n1;
 		mNode2 = n2;
+                mLastModifiedTime = new Long(System.currentTimeMillis());
 	}
 
 	/* (non-Javadoc)
@@ -113,4 +115,18 @@ class DummyLinkImpl extends DummyGraphElement implements Link {
 	public String toString() {
 		return "dlink{" + getNode1() + ", " + getNode2() + "}";
 	}
+        @Override
+        public void setRemovedTime() {
+               mLastModifiedTime = new Long(System.currentTimeMillis());
+        }
+
+        @Override
+        public Long getRemovedTime() {
+               return mLastModifiedTime;
+        }
+
+        @Override
+        public Long getLastModifiedTime() {
+               return mLastModifiedTime;
+        }
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyNodeImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyNodeImpl.java
index bf9d1c5..7c4a668 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyNodeImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/DummyNodeImpl.java
@@ -30,10 +30,13 @@ import de.fhhannover.inform.iron.mapserver.utils.NullCheck;
 class DummyNodeImpl extends DummyGraphElement implements Node {
 	
 	private final Identifier mIdentifier;
+        private Long mLastModifiedTime;
+
 	
 	DummyNodeImpl(Identifier ident) {
 		NullCheck.check(ident, "ident is null");
 		mIdentifier = ident;
+                mLastModifiedTime = new Long(System.currentTimeMillis());
 	}
 
 	/* (non-Javadoc)
@@ -60,6 +63,11 @@ class DummyNodeImpl extends DummyGraphElement implements Node {
 		throw new SystemErrorException(sErrorString);
 	}
 
+        @Override
+        public boolean hasLink(Link l) {
+		throw new SystemErrorException(sErrorString);
+        }
+
 	/* (non-Javadoc)
 	 * @see de.fhhannover.inform.iron.mapserver.datamodel.graph.Node#removeLink(de.fhhannover.inform.iron.mapserver.datamodel.graph.Link)
 	 */
@@ -113,4 +121,19 @@ class DummyNodeImpl extends DummyGraphElement implements Node {
 	public String toString() {
 		return "dnode{" + getIdentifier() + "}";
 	}
+
+        @Override
+        public void setRemovedTime() {
+               mLastModifiedTime = new Long(System.currentTimeMillis());
+        }
+
+        @Override
+        public Long getRemovedTime() {
+               return mLastModifiedTime;
+        }
+
+        @Override
+        public Long getLastModifiedTime() {
+               return mLastModifiedTime;
+        }
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElement.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElement.java
index c9ce00e..9bf3a3e 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElement.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElement.java
@@ -198,4 +198,8 @@ public interface GraphElement extends SearchAble {
 	 * 			{@link GraphElement} object.
 	 */
 	public void removeAllRemovedSubscriptionEntries();
+
+        abstract public void setRemovedTime();
+        abstract public Long getRemovedTime();
+        abstract Long getLastModifiedTime();
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepository.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepository.java
index 670735d..8c0570c 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepository.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepository.java
@@ -23,6 +23,7 @@ package de.fhhannover.inform.iron.mapserver.datamodel.graph;
 
 import java.util.Collection;
 
+import de.fhhannover.inform.iron.mapserver.communication.ifmap.SessionRepository;
 import de.fhhannover.inform.iron.mapserver.datamodel.identifiers.Identifier;
 
 /**
@@ -95,4 +96,11 @@ public interface GraphElementRepository {
 	 * Make some debugging output about the content of the graph.
 	 */
 	public void dumpContents();
+
+	/**
+	 * Notify the repository that metadataholder has been removed
+	 */
+	public void metadataHoldeRemoved(GraphElement ge);
+
+        public void setSessionRepo(SessionRepository sessionRepo);
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepositoryImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepositoryImpl.java
index aafa438..0c61adf 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepositoryImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/GraphElementRepositoryImpl.java
@@ -22,8 +22,22 @@
 package de.fhhannover.inform.iron.mapserver.datamodel.graph;
 
 import java.util.Collection;
+import java.util.List;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.ArrayList;
+import java.util.Timer;
+import java.util.TimerTask;
 
+import org.apache.log4j.Logger;
+
+import de.fhhannover.inform.iron.mapserver.datamodel.Publisher;
+import de.fhhannover.inform.iron.mapserver.datamodel.PublisherRep;
 import de.fhhannover.inform.iron.mapserver.datamodel.identifiers.Identifier;
+import de.fhhannover.inform.iron.mapserver.datamodel.search.Subscription;
+import de.fhhannover.inform.iron.mapserver.communication.ifmap.SessionRepository;
+import de.fhhannover.inform.iron.mapserver.exceptions.SystemErrorException;
+import de.fhhannover.inform.iron.mapserver.provider.LoggingProvider;
 import de.fhhannover.inform.iron.mapserver.utils.CollectionHelper;
 import de.fhhannover.inform.iron.mapserver.utils.MultiArrayListMap;
 import de.fhhannover.inform.iron.mapserver.utils.MultiMap;
@@ -37,30 +51,133 @@ import de.fhhannover.inform.iron.mapserver.utils.NullCheck;
  * @author aw
  */
 public class GraphElementRepositoryImpl implements GraphElementRepository {
-	
+	private final static Logger sLogger = LoggingProvider.getTheLogger();
 	private MultiMap<Integer, Node> mNodes;
 	private MultiMap<Integer, Link> mLinks;
-	
+	private PublisherRep mPublisherRep;
+        private Timer mCleanupTimer;
+        private int mCleanupInterval = 60;
+        private List<GraphElement> mRemovedElements;
+        private SessionRepository mSessionRep;
+
 	/**
+	 * @param publisherRep
 	 * @return a new Instance of a {@link GraphElementRepository} instance.
 	 */
-	public static GraphElementRepository newInstance() {
-		return new GraphElementRepositoryImpl();
+	public static GraphElementRepository newInstance(PublisherRep publisherRep) {
+	    return new GraphElementRepositoryImpl(publisherRep);
 	}
 	
 	/**
 	 * Private constructor
+	 * @param publisherRep
 	 */
-	private GraphElementRepositoryImpl() {
+	private GraphElementRepositoryImpl(PublisherRep publisherRep) {
 		mNodes = new MultiArrayListMap<Integer, Node>();
 		mLinks = new MultiArrayListMap<Integer, Link>();
+		mPublisherRep = publisherRep;
+                mRemovedElements = new ArrayList<GraphElement>();
+                startCleanupTimer();
 	}
 
+        @Override
+        public void setSessionRepo(SessionRepository sessionRepo) {
+                mSessionRep = sessionRepo;
+        }
+
+        public class CleanupTask extends TimerTask {
+
+                @Override
+                public void run() {
+                    try {
+                         sLogger.debug("Cleanup task started");
+                         /* replace with the actual task */
+                         try {
+                              Thread.sleep(mCleanupInterval * 1000);
+                         } catch(InterruptedException e) {
+                              e.printStackTrace();
+                         }
+                         int count = removeElements();
+                         sLogger.debug("Cleanup task done, number of elements removed: " + count);
+                         mCleanupTimer.schedule(new CleanupTask(), 0, 10);
+                    } catch (Exception ex) {
+                         sLogger.debug(ex);
+                         sLogger.info("Unable to run clean up task");
+                    }
+                }
+        }
+
+        public void startCleanupTimer() {
+                /* Start background task */
+                mCleanupTimer = new Timer("CleanupTimer");
+                try {
+                        mCleanupTimer.schedule(new CleanupTask(), 0);
+                } catch (Exception ex) {
+                    sLogger.debug("Unable to start Cleanup timer " + ex.getMessage());
+                    sLogger.debug("timer start", ex);
+                }
+        }
+
+        /* use this utility for debug purpose to dump all the conents in session->visited element time stamp map */
+        public void dumpGraphElementVisitedTime() {
+               for (GraphElement ge:mRemovedElements) {
+                    sLogger.debug("Remove time: " + ge.getRemovedTime() + ", GE: " + ge);
+               }
+               Long time = new Long(-1);
+               Map<String, Long> mSessionElementVisitTime = mSessionRep.getSessionElementVisitTimeMap();
+               Iterator it = mSessionElementVisitTime.entrySet().iterator();
+               sLogger.debug("Session Channel Visit Data:");
+               while (it.hasNext()) {
+                     Map.Entry pair = (Map.Entry)it.next();
+                     String sesId = (String)pair.getKey();
+                     Long t = (Long)pair.getValue();
+                     sLogger.debug("Old item visited time stamp for Session: " + sesId + ", time: " + t);
+               }
+               return;
+        }
+
+        public synchronized int removeElements() {
+               int count = 0;
+               Iterator<GraphElement> it = mRemovedElements.iterator();
+               while (it.hasNext()) {
+                    GraphElement ge = it.next();
+                    sLogger.debug("Remove time: " + ge.getRemovedTime() + "; " + " OldestVisit: " + mSessionRep.oldestGraphElementVisitedTime() + ";ge: " + ge);
+                    Long curTime = new Long(System.currentTimeMillis());
+                    if ((curTime >= (ge.getRemovedTime() + 10)) && (ge.getRemovedTime() <= mSessionRep.oldestGraphElementVisitedTime())) {
+                         if (ge instanceof Node) {
+                              if (mNodes.getAll(nodeKey((Node)ge)) == null) {
+                                  continue;
+                              }
+                              if (!cleanupChecks((Node)ge)) {
+                                  continue;
+                              }
+                              cleanupNonMeaningfulNode((Node) ge);
+                              count++;
+                              it.remove();
+                         } else if (ge instanceof Link) {
+                              if (mLinks.getAll(linkKey((Link)ge)) == null) {
+                                  continue;
+                              }
+                              if (!cleanupChecks((Link)ge)) {
+                                  continue;
+                              }
+                              cleanupNonMeaningfulLink((Link) ge);
+                              count++;
+                              it.remove();
+                         } else {
+                              throw new SystemErrorException("GraphElement not Link nor Identifier");
+                         }
+                    }
+               }
+               sLogger.info("Collector - Number of elements removed from graph: " + count);
+               return count;
+        }
+
 	/* (non-Javadoc)
 	 * @see de.fhhannover.inform.iron.mapserver.datamodel.graph.GraphElementRepository#getNodeFor(de.fhhannover.inform.iron.mapserver.datamodel.identifiers.Identifier)
 	 */
 	@Override
-	public Node getNodeFor(Identifier i) {
+	public synchronized Node getNodeFor(Identifier i) {
 		/* Find a node in the existing nodes which has the same identifier
 		 * attached. We shouldn't get back too many nodes, so search should
 		 * be OK.
@@ -81,7 +198,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	 * @see de.fhhannover.inform.iron.mapserver.datamodel.graph.GraphElementRepository#getLinkFor(de.fhhannover.inform.iron.mapserver.datamodel.identifiers.Identifier, de.fhhannover.inform.iron.mapserver.datamodel.identifiers.Identifier)
 	 */
 	@Override
-	public Link getLinkFor(Identifier i1, Identifier i2) {
+	public synchronized Link getLinkFor(Identifier i1, Identifier i2) {
 		Link l = findExistingLinkFor(i1, i2);
 	
 		// if there is no such Link, create a new one based on Nodes from the
@@ -102,7 +219,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	}
 
 	@Override
-	public GraphElement getGraphElement(Identifier i1, Identifier i2) {
+	public synchronized GraphElement getGraphElement(Identifier i1, Identifier i2) {
 		if (i1 == null && i2 == null)
 			throw new NullPointerException("Both Identifiers null"); /* bail out */
 		else if (i1 != null && i2 == null)
@@ -114,7 +231,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	}
 
 	@Override
-	public Node getGraphElement(Identifier i1) {
+	public synchronized Node getGraphElement(Identifier i1) {
 		return (Node)getGraphElement(i1, null);
 	}
 
@@ -122,7 +239,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	 * @see de.fhhannover.inform.iron.mapserver.datamodel.graph.GraphElementRepository#getAllNodes()
 	 */
 	@Override
-	public Collection<Node> getAllNodes() {
+	public synchronized Collection<Node> getAllNodes() {
 		Collection<Node> ret = CollectionHelper.provideCollectionFor(Node.class);
 		
 		for (Node n : mNodes.values())
@@ -136,7 +253,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	 */
 	
 	@Override
-	public Collection<Link> getAllLinks() {
+	public synchronized Collection<Link> getAllLinks() {
 		Collection<Link> ret = CollectionHelper.provideCollectionFor(Link.class);
 		
 		for (Link l : mLinks.values())
@@ -149,7 +266,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	 * @see de.fhhannover.inform.iron.mapserver.datamodel.graph.GraphElementRepository#getAllElements()
 	 */
 	@Override
-	public Collection<GraphElement> getAllElements() {
+	public synchronized Collection<GraphElement> getAllElements() {
 		Collection<GraphElement> ret = CollectionHelper.provideCollectionFor(GraphElement.class);
 		ret.addAll(getAllNodes());
 		ret.addAll(getAllLinks());
@@ -179,7 +296,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	 * @param i
 	 * @return
 	 */
-	private Node findExistingNodeFor(Identifier i) {
+	private synchronized Node findExistingNodeFor(Identifier i) {
 		for (Node node : mNodes.getAll(nodeKey(i)))
 			if (node.getIdentifier().equals(i))
 				return node;
@@ -194,7 +311,7 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	 * @param i2
 	 * @return
 	 */
-	private Link findExistingLinkFor(Identifier i1, Identifier i2) {
+	private synchronized Link findExistingLinkFor(Identifier i1, Identifier i2) {
 		for (Link link : mLinks.getAll(linkKey(i1, i2)))
 			if (linkHasIdentifiers(link, i1, i2))
 					return link;
@@ -211,29 +328,169 @@ public class GraphElementRepositoryImpl implements GraphElementRepository {
 	 * @param i2
 	 * @return
 	 */
-	private boolean linkHasIdentifiers(Link link, Identifier i1, Identifier i2) {
+	private synchronized boolean linkHasIdentifiers(Link link, Identifier i1, Identifier i2) {
 		Identifier li1 = link.getNode1().getIdentifier();
 		Identifier li2 = link.getNode2().getIdentifier();
 		return i1.equals(li1) && i2.equals(li2) || i1.equals(li2) && i2.equals(li1);
 	}
 	
-	private int linkKey(Link l) {
+	private synchronized int linkKey(Link l) {
 		return linkKey(l.getNode1(), l.getNode2());
 	}
 
-	private int linkKey(Node n1, Node n2) {
+	private synchronized int linkKey(Node n1, Node n2) {
 		return linkKey(n1.getIdentifier(), n2.getIdentifier());
 	}
 	
-	private int linkKey(Identifier i1, Identifier i2) {
+	private synchronized int linkKey(Identifier i1, Identifier i2) {
 		return nodeKey(i1) + nodeKey(i2);
 	}
 	
-	private int nodeKey(Node n) {
+	private synchronized int nodeKey(Node n) {
 		return nodeKey(n.getIdentifier());
 	}
 	
-	private int nodeKey(Identifier i) {
+	private synchronized int nodeKey(Identifier i) {
 		return i.hashCode();
 	}
+
+	/**
+	 * A confirmed non meaninful element  is an element
+	 * without any metadata after a delay
+	 */
+	private synchronized boolean isMeaningful(GraphElement element) {
+		if (element.getMetadataHolder().size() > 0)
+			return true;
+
+		return false;
+	}
+
+	private synchronized boolean hasMeaningfulLink(Node node) {
+		for (Link link : node.getLinks()) {
+			if (isMeaningful(link)) {
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+        private synchronized boolean cleanupChecks(Node node) {
+                Long curTime = new Long(System.currentTimeMillis());
+                Long oldtestVisitedTime = mSessionRep.oldestGraphElementVisitedTime();
+                if ((curTime < (node.getRemovedTime() + 10)) || (node.getRemovedTime() > oldtestVisitedTime)) {
+                        return false;
+                }
+                for (Link link : node.getLinks()) {
+                        if (mLinks.getAll(linkKey(link)) == null) {
+                             continue;
+                        }
+                        if ((curTime < (link.getRemovedTime() + 10)) || (link.getRemovedTime() > oldtestVisitedTime)) {
+                             return false;
+                        }
+                }
+                return true; 
+        }
+
+        private synchronized boolean cleanupChecks(Link link) {
+                Long curTime = new Long(System.currentTimeMillis());
+                Long oldtestVisitedTime = mSessionRep.oldestGraphElementVisitedTime();
+                if ((curTime < (link.getRemovedTime() + 10)) || (link.getRemovedTime() > oldtestVisitedTime)) {
+                        return false;
+                }
+                Node node1 = link.getNode1();
+                if (node1 != null && mNodes.getAll(nodeKey(node1)) != null) {
+                    if ((curTime < (node1.getRemovedTime() + 10)) || (node1.getRemovedTime() > oldtestVisitedTime)) {
+                           return false;
+                    }
+                }
+                Node node2 = link.getNode2();
+                if (node2 != null && mNodes.getAll(nodeKey(node2)) != null) {
+                    if ((curTime < (node2.getRemovedTime() + 10)) || (node2.getRemovedTime() > oldtestVisitedTime)) {
+                           return false;
+                    }
+                }
+                return true;
+        }
+
+	private synchronized void cleanupNonMeaningfulNode(Node node) {
+		if (isMeaningful(node) || hasMeaningfulLink(node)) {
+			return;
+		}
+
+		sLogger.trace("Removing a non meaningful node: " + node);
+		cleanupSubscribtions(node);
+		mNodes.remove(nodeKey(node.getIdentifier()), node);
+
+		for (Link link : node.getLinks()) {
+                        if (mLinks.getAll(linkKey(link)) == null) {
+                             continue;
+                        }
+			cleanupSubscribtions(link);
+                        if (link.getNode1().hasLink(link)) {
+			     link.getNode1().removeLink(link);
+                        }
+                        if (link.getNode2().hasLink(link)) {
+		             link.getNode2().removeLink(link);
+                        }
+			sLogger.trace("Removing a non meaningful link: " + link);
+			mLinks.remove(linkKey(link), link);
+		}
+	}
+
+	private synchronized void cleanupNonMeaningfulLink(Link link) {
+		// should never happen since this is called from a method that just
+		// removed the metadatas
+		if (isMeaningful(link)) {
+			return;
+		}
+
+		sLogger.trace("Removing a non meaningful link: " + link);
+		cleanupSubscribtions(link);
+		mLinks.remove(linkKey(link), link);
+
+                if (link.getNode1().hasLink(link)) {
+		    link.getNode1().removeLink(link);
+                }
+                if (mNodes.getAll(nodeKey(link.getNode1())) != null) {
+		    cleanupNonMeaningfulNode(link.getNode1());
+                }
+
+                if (link.getNode1().hasLink(link)) {
+		    link.getNode2().removeLink(link);
+                }
+                if (mNodes.getAll(nodeKey(link.getNode2())) != null) {
+		    cleanupNonMeaningfulNode(link.getNode2());
+                }
+	}
+
+	private synchronized void cleanupSubscribtions(GraphElement removed) {
+		for (Publisher pub : mPublisherRep.getPublishers()) {
+			List<Subscription> subs = pub.getSubscriptionState().getSubscriptions();
+			for (Subscription sub : subs) {
+				sLogger.trace("Removing a non meaningful element " + removed +
+					" from subscriber : " + sub);
+                                try {
+				    sub.removeGraphElementRemoved(removed);
+                                } catch (SystemErrorException e) {
+				    sLogger.trace("Already removed: " + removed + " from sub: " + sub);
+                                    continue;
+                                }
+			}
+		}
+	}
+
+        private synchronized void markElementForRemoval(GraphElement ge) {
+                mRemovedElements.add(ge);
+        }
+
+	public synchronized void metadataHoldeRemoved(GraphElement ge) {
+                sLogger.debug("Removal Request for Element: " + ge);
+		if (ge instanceof Node)
+			markElementForRemoval(ge);
+		else if (ge instanceof Link)
+			markElementForRemoval(ge);
+		else
+			throw new SystemErrorException("GraphElement not Link nor Identifier");
+	}
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/LinkImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/LinkImpl.java
index 38b0ccb..161ffa5 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/LinkImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/LinkImpl.java
@@ -28,6 +28,7 @@ class LinkImpl extends GraphElementImpl implements Link {
 	
 	private final Node mNode1, mNode2;
 	private final Link mDummy;
+        private Long mLastModifiedTime;
 	
 	LinkImpl(Node n1, Node n2) {
 		NullCheck.check(n1, "n1 is null");
@@ -36,7 +37,24 @@ class LinkImpl extends GraphElementImpl implements Link {
 		mNode1 = n1;
 		mNode2 = n2;
 		mDummy = new DummyLinkImpl((Node)mNode1.dummy(), (Node)mNode2.dummy());
+                mLastModifiedTime = new Long(System.currentTimeMillis());
 	}
+
+        @Override
+        public void setRemovedTime() {
+               mLastModifiedTime = new Long(System.currentTimeMillis());
+               mDummy.setRemovedTime();
+        }
+
+        @Override
+        public Long getRemovedTime() {
+               return mLastModifiedTime;
+        }
+
+        @Override
+        public Long getLastModifiedTime() {
+               return mLastModifiedTime;
+        }
 	
 	@Override
 	public Node getNode1() {
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/Node.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/Node.java
index 9290904..4496098 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/Node.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/Node.java
@@ -54,6 +54,8 @@ public interface Node extends GraphElement {
 	 * @param l
 	 */
 	public void addLink(Link l);
+
+        public boolean hasLink(Link l);
 	
 	/**
 	 * Remove a {@link Link} object from this {@link Node} object.
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/NodeImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/NodeImpl.java
index cd00fdb..cf74fc8 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/NodeImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/graph/NodeImpl.java
@@ -34,15 +34,33 @@ class NodeImpl extends GraphElementImpl implements Node {
 	private final Identifier mIdentifier;
 	private final Map<Integer, Link> mLinks;
 	private final Node mDummy;
+        private Long mLastModifiedTime;
 	
 	NodeImpl(Identifier i) {
 		super();
 		NullCheck.check(i, "Identifier is null");
 		mIdentifier = i;
-		mLinks = CollectionHelper.provideMapFor(Integer.class, Link.class);
+		mLinks = CollectionHelper.provideConcurrentMapFor(Integer.class, Link.class);
 		mDummy = new DummyNodeImpl(i);
+                mLastModifiedTime = new Long(System.currentTimeMillis());
 	}
 
+        @Override
+        public void setRemovedTime() {
+               mLastModifiedTime = new Long(System.currentTimeMillis());
+               mDummy.setRemovedTime();
+        }
+
+        @Override
+        public Long getRemovedTime() {
+               return mLastModifiedTime;
+        }
+
+        @Override
+        public Long getLastModifiedTime() {
+               return mLastModifiedTime;
+        }
+
 	@Override
 	public Identifier getIdentifier() {
 		return mIdentifier;
@@ -63,6 +81,14 @@ class NodeImpl extends GraphElementImpl implements Node {
 	}
 
 	@Override
+	public boolean hasLink(Link l) {
+		NullCheck.check(l, "link is null");
+		if (mLinks.containsKey(l.hashCode()))
+	                return true;
+                return false;
+        }
+
+	@Override
 	public void removeLink(Link l) {
 		NullCheck.check(l, "link is null");
 		if (!mLinks.containsKey(l.hashCode()))
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/meta/W3cXmlMetadata.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/meta/W3cXmlMetadata.java
index dbdfe80..1bcd11f 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/meta/W3cXmlMetadata.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/meta/W3cXmlMetadata.java
@@ -76,6 +76,7 @@ class W3cXmlMetadata extends Metadata {
 			xpathFactory = XPathFactory.newInstance();
 			documentBuilderFactory = DocumentBuilderFactory.newInstance();
 			documentBuilderFactory.setNamespaceAware(true);
+			documentBuilderFactory.setFeature("http://apache.org/xml/features/dom/defer-node-expansion", false);
 			documentBuilder = documentBuilderFactory.newDocumentBuilder();
 			transformerFactory = TransformerFactory.newInstance();
 		} catch (ParserConfigurationException e) {
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/CopySearchResultImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/CopySearchResultImpl.java
index ac9c637..b463fd8 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/CopySearchResultImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/CopySearchResultImpl.java
@@ -77,4 +77,5 @@ class CopySearchResultImpl extends SearchResultImpl {
 		if (m != null)
 			mLastResultItem.addMetadata(m);
 	}
+
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiablePollResult.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiablePollResult.java
index cd5bd17..ba25918 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiablePollResult.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiablePollResult.java
@@ -43,4 +43,6 @@ public interface ModifiablePollResult extends PollResult {
 	public void addSearchResult(ModifiableSearchResult res, Integer mpprs);
 	
 	public void removeResultsOf(String name);
+        public void setOldtestItemTimeStamp(Long ts);
+        public Long getOldtestItemTimeStamp();
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiableSearchResult.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiableSearchResult.java
index d75b478..93e9ec9 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiableSearchResult.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/ModifiableSearchResult.java
@@ -71,4 +71,7 @@ public interface ModifiableSearchResult extends SearchResult {
 
         public boolean isSearchTypeInitialRun();
 
+        public void setOldtestItemTimeStamp(Long ts);
+        public Long getOldtestItemTimeStamp();
+
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResult.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResult.java
index cd396f8..7204e9e 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResult.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResult.java
@@ -74,4 +74,6 @@ public interface PollResult extends SearchAble {
 
         public void addSearchResult(ModifiableSearchResult sres, Integer mpprs);
         public void addErrorResult(String name);
+        public void setOldtestItemTimeStamp(Long ts);
+        public Long getOldtestItemTimeStamp();
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResultImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResultImpl.java
index 6d95442..c5ef3bf 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResultImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/PollResultImpl.java
@@ -52,12 +52,14 @@ public class PollResultImpl implements ModifiablePollResult {
 	private int mCurSize;
         private final SearchingFactory mSearchFac;
         private static Logger sLogger = LoggingProvider.getTheLogger();
+        private Long mOldtestItemTimeStamp;
 
 	public PollResultImpl() {
 		mResults = CollectionHelper.provideListFor(ModifiableSearchResult.class);
 		mErrors = CollectionHelper.provideListFor(String.class);
 		mCurSize = 0;
                 mSearchFac = SearchingFactoryImpl.newInstance();
+                mOldtestItemTimeStamp = new Long(System.currentTimeMillis());
 	}
 	
 	/* (non-Javadoc)
@@ -79,6 +81,16 @@ public class PollResultImpl implements ModifiablePollResult {
 		return Collections.unmodifiableList(mErrors);
 	}
 
+	@Override
+	public void setOldtestItemTimeStamp(Long ts) {
+                mOldtestItemTimeStamp = ts;
+	}
+
+	@Override
+	public Long getOldtestItemTimeStamp() {
+                return mOldtestItemTimeStamp;
+	}
+
 	/* (non-Javadoc)
 	 * @see de.fhhannover.inform.iron.mapserver.datamodel.search.ModifiablePollResult#addErrorResult(java.lang.String)
 	 */
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SearchResultImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SearchResultImpl.java
index c09108e..689d027 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SearchResultImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SearchResultImpl.java
@@ -72,6 +72,8 @@ abstract class SearchResultImpl implements ModifiableSearchResult {
 	 */
 	protected GraphElement mLastGraphElement;
 
+        protected Long mOldtestItemTimeStamp;
+
 	/**
 	 * Constructor to create {@link SearchResult} instances.
 	 * 
@@ -90,6 +92,7 @@ abstract class SearchResultImpl implements ModifiableSearchResult {
 		mResultItems = CollectionHelper.provideListFor(ResultItem.class);
 		mLastResultItem = null;
                 mIsSearchTypeInitial = false;
+                mOldtestItemTimeStamp = new Long(System.currentTimeMillis());
 	}
 	
 	/**
@@ -109,7 +112,7 @@ abstract class SearchResultImpl implements ModifiableSearchResult {
 	protected SearchResultImpl() {
 		this(null, SearchResultType.SEARCH);
 	}
-	
+
 	/* (non-Javadoc)
 	 * @see de.fhhannover.inform.iron.mapserver.datamodel.search.SearchResult#getResultItems()
 	 */
@@ -270,4 +273,14 @@ abstract class SearchResultImpl implements ModifiableSearchResult {
 		
 		return o.getType() == getType() && o.getName().equals(getName());
 	}
+
+	@Override
+        public Long getOldtestItemTimeStamp() {
+                return mOldtestItemTimeStamp;
+        }
+
+	@Override
+        public void setOldtestItemTimeStamp(Long ts) {
+                mOldtestItemTimeStamp = ts;
+        }
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/Subscription.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/Subscription.java
index e850dfa..6a51733 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/Subscription.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/Subscription.java
@@ -65,4 +65,6 @@ public interface Subscription {
 
 	public void setExceededSize();
 
+	public void removeGraphElementRemoved(GraphElement mc);
+
 }
\ No newline at end of file
diff --git a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SubscriptionImpl.java b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SubscriptionImpl.java
index 6df3b61..2ec0398 100644
--- a/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SubscriptionImpl.java
+++ b/src/de/fhhannover/inform/iron/mapserver/datamodel/search/SubscriptionImpl.java
@@ -237,4 +237,10 @@ class SubscriptionImpl implements Subscription {
 		// TODO: Cache
 		return "sub{" + getName() + ", " + getPublisherReference() + "}";
 	}
+
+	@Override
+	public void removeGraphElementRemoved(GraphElement ge) {
+		NullCheck.check(ge, "ge is null");
+		mGraphElements.remove(ge);
+	}
 }
diff --git a/src/de/fhhannover/inform/iron/mapserver/utils/CollectionHelper.java b/src/de/fhhannover/inform/iron/mapserver/utils/CollectionHelper.java
index 45a1e84..7233264 100644
--- a/src/de/fhhannover/inform/iron/mapserver/utils/CollectionHelper.java
+++ b/src/de/fhhannover/inform/iron/mapserver/utils/CollectionHelper.java
@@ -28,6 +28,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Lets make use of this to allocate the same type of list, collection and
@@ -58,6 +59,10 @@ public class CollectionHelper {
 		return new HashMap<T, V>();
 	}
 
+	public static <T, V> Map<T, V> provideConcurrentMapFor(Class<T> c1, Class<V> c2) {
+		return new ConcurrentHashMap<T, V>();
+	}
+
 	public static <T> Set<T> provideSetFor(Class<T> c) {
 		return new HashSet<T>();
 	}
diff --git a/src/de/fhhannover/inform/iron/mapserver/utils/MultiArrayListMap.java b/src/de/fhhannover/inform/iron/mapserver/utils/MultiArrayListMap.java
index da9b357..0bd6eda 100644
--- a/src/de/fhhannover/inform/iron/mapserver/utils/MultiArrayListMap.java
+++ b/src/de/fhhannover/inform/iron/mapserver/utils/MultiArrayListMap.java
@@ -23,11 +23,11 @@ package de.fhhannover.inform.iron.mapserver.utils;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 public class MultiArrayListMap<K, V> implements MultiMap<K, V>{
 	
@@ -36,7 +36,7 @@ public class MultiArrayListMap<K, V> implements MultiMap<K, V>{
 	private int mSize;
 	
 	public MultiArrayListMap() {
-		mMapOfLists = new HashMap<K, List<V>>();
+		mMapOfLists = new ConcurrentHashMap<K, List<V>>();
 		mSize = 0;
 	}
 
@@ -72,12 +72,17 @@ public class MultiArrayListMap<K, V> implements MultiMap<K, V>{
 		if (list == null) {
 			list = new ArrayList<V>();
 			mMapOfLists.put(key, list);
-		} else if (idx >= 0) {
+			idx = -1;
+		}
+		synchronized (list) {
+		if (idx >= 0) {
 			ret = list.remove(idx);
 			mSize--;
 		}
 		
 		list.add(value);
+	}
+
 		mSize++;
 		return ret;
 	}
